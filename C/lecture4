
операторы присваивания 
=
+=
-=
*=
/=
%=
<<=
>>=
^=
&=
правоассоциативны
то есть если 
x=y=z
x=(y=z)




операторы 
+
-
*
/
%
арифметические операторы


<<
>>
<=
>=
>
<
==
|=

comparison operators


|
&
^
bitwise operators

&&
||
logical operators


левоассоциативны
то есть
a+b+c=(a+b)+c

Для int особо разницы вроде нет какая ассоциативность,
но вот для float разница уже есть
Например 
a*a*a*a
компилятор мог вычислить так оптимизированно
(a*a)*(a*a) то есть компилятор мог бы выполянть только два умножения
порядок значит важен для чисел с плавающей запятой.
Поэтому компилятор не оптимизирует, чтоб не потерять точность.

Ассоциативность компилятор не меняет.



v.size()>=5 && v[4]==1
правил ленивых вычислений
оператор && гарантирует что не вычисляет правый аргумент если не посчитает ллевый.




Инкремент и декремент

++a префиксный - это увеличение переменной на едицицу и возвращение то что получилось
a++ профиксный это увеличение переменной на единицу и возвращение того что было

то есть ++a - префиксное это lvalue
        a++ - постфиксное это rvalue

сам инкремент применим только к lvalue(то есть мы можем инкрементировать только переменные ,
 а не временные значения, которые были получены в процессе вычисления),
 но результат либо lvalue или rvalue

то есть можно написать :

++(x=5) - это корректно потому что x=5 - lvalue

++a++ будет как компилятор парсит синтаксически

постфиксные сначала компилятор парсит , а потом префиксные - это грамматика
поэтому будет:
++(a++)

a+++++b - лексический парсер работает по принципу - я отщипываю символы как можно
 больше пока есть смысл токена. это лексика

то есть это будет:
a|++|++|+|b то есть нельзя

а вот
++++a потомучто будет ++(++а)
жадный лексический парсер - компилятор обычно так и работает



ТЕРНАРНЫЙ ОПЕРАТОР

...?....:....






